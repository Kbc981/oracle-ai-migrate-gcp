
import { ConversionResult, CodeFile, ConversionIssue } from '@/types';

// Enhanced AI-based code conversion with comprehensive Sybase to Oracle rules
export const convertSybaseToOracle = async (file: CodeFile, aiModel: string = 'default'): Promise<ConversionResult> => {
  console.log(`Converting with ${aiModel} AI model`);
  
  // Simulate processing time
  await new Promise(resolve => setTimeout(resolve, 1500));
  
  // Generate conversion result with comprehensive syntax rules
  let convertedCode = '';
  const issues: ConversionIssue[] = [];
  
  // Apply conversion based on file type
  if (file.type === 'table') {
    convertedCode = simulateTableConversion(file.content);
  } else if (file.type === 'procedure') {
    convertedCode = simulateProcedureConversion(file.content);
  } else if (file.type === 'trigger') {
    convertedCode = simulateTriggerConversion(file.content);
  } else {
    convertedCode = simulateGenericConversion(file.content);
  }
  
  // Add header comment
  convertedCode = `-- Converted Oracle code for ${file.name}\n${convertedCode}`;
  
  // Validate converted code
  const validationIssues = validateOracleCode(convertedCode);
  issues.push(...validationIssues);
  
  // Add random issues to simulate AI detection
  if (Math.random() > (aiModel === 'gemini' ? 0.8 : 0.6)) {
    issues.push({
      id: crypto.randomUUID(),
      lineNumber: Math.floor(Math.random() * 20) + 1,
      description: 'Potential data type optimization needed',
      severity: 'warning',
      originalCode: 'DECIMAL(10,2)',
      suggestedFix: 'NUMBER(10,2)'
    });
  }
  
  return {
    id: crypto.randomUUID(),
    originalFile: file,
    convertedCode,
    issues,
    performance: {
      originalComplexity: Math.floor(Math.random() * 100) + 50,
      convertedComplexity: Math.floor(Math.random() * 50) + 20,
      improvementPercentage: aiModel === 'gemini' ? Math.floor(Math.random() * 50) + 25 : Math.floor(Math.random() * 40) + 15,
      notes: ['Replaced concatenation with Oracle ||', 'Optimized date functions', 'Improved error handling']
    },
    status: issues.some(i => i.severity === 'error') ? 'error' : 
            issues.length > 0 ? 'warning' : 'success'
  };
};

// Comprehensive table conversion with all Sybase to Oracle rules
const simulateTableConversion = (sybaseCode: string): string => {
  let oracleCode = sybaseCode
    // Data type conversions - Enhanced rules
    .replace(/\bINT\b/gi, 'NUMBER')
    .replace(/\bBIGINT\b/gi, 'NUMBER(19)')
    .replace(/\bSMALLINT\b/gi, 'NUMBER(5)')
    .replace(/\bTINYINT\b/gi, 'NUMBER(3)')
    .replace(/\bFLOAT\s*\(\s*(\d+)\s*\)/gi, 'NUMBER($1)')
    .replace(/\bFLOAT\b/gi, 'BINARY_FLOAT')
    .replace(/\bREAL\b/gi, 'BINARY_FLOAT')
    .replace(/\bDECIMAL\s*\(\s*(\d+)\s*,\s*(\d+)\s*\)/gi, 'NUMBER($1,$2)')
    .replace(/\bNUMERIC\s*\(\s*(\d+)\s*,\s*(\d+)\s*\)/gi, 'NUMBER($1,$2)')
    .replace(/\bVARCHAR\s*\(\s*(\d+)\s*\)/gi, 'VARCHAR2($1)')
    .replace(/\bCHAR\s*\(\s*(\d+)\s*\)/gi, 'CHAR($1)')
    .replace(/\bDATETIME\b/gi, 'DATE')
    .replace(/\bSMALLDATETIME\b/gi, 'DATE')
    .replace(/\bTIMESTAMP\b/gi, 'TIMESTAMP')
    .replace(/\bBIT\b/gi, 'NUMBER(1)')
    .replace(/\bTEXT\b/gi, 'CLOB')
    .replace(/\bNTEXT\b/gi, 'NCLOB')
    .replace(/\bIMAGE\b/gi, 'BLOB')
    .replace(/\bBINARY\s*\(\s*(\d+)\s*\)/gi, 'RAW($1)')
    .replace(/\bVARBINARY\s*\(\s*(\d+)\s*\)/gi, 'RAW($1)')
    // Default values and functions
    .replace(/\bGETDATE\(\)/gi, 'SYSDATE')
    .replace(/\bgetdate\(\)/gi, 'SYSDATE')
    .replace(/\bNEWID\(\)/gi, 'SYS_GUID()')
    // Identity columns
    .replace(/IDENTITY\s*\(\s*(\d+)\s*,\s*(\d+)\s*\)/gi, 'GENERATED BY DEFAULT AS IDENTITY (START WITH $1 INCREMENT BY $2)')
    .replace(/\bIDENTITY\b/gi, 'GENERATED ALWAYS AS IDENTITY')
    // Remove square brackets
    .replace(/\[([^\]]+)\]/g, '$1')
    // Clean up table options
    .replace(/ON\s+\[PRIMARY\]/gi, '')
    .replace(/WITH\s*\(\s*[^)]*\)/gi, '')
    .replace(/TEXTIMAGE_ON\s+\[PRIMARY\]/gi, '');

  return oracleCode;
};

// Comprehensive stored procedure conversion
const simulateProcedureConversion = (sybaseCode: string): string => {
  const procName = extractProcedureName(sybaseCode) || 'converted_proc';
  
  let oracleCode = sybaseCode
    // Remove CREATE PROCEDURE header (we'll add Oracle version)
    .replace(/CREATE\s+PROCEDURE\s+\w+/gi, '')
    // Variable declarations and assignments
    .replace(/@(\w+)/g, 'v_$1')
    .replace(/DECLARE\s+@(\w+)\s+([^,;]+)/gi, 'v_$1 $2;')
    .replace(/SET\s+@(\w+)\s*=\s*/gi, 'v_$1 := ')
    .replace(/SELECT\s+@(\w+)\s*=\s*/gi, 'SELECT INTO v_$1 ')
    .replace(/SELECT\s+@(\w+)\s*=\s*(.+)\s+FROM\s+(.+)/gi, 'SELECT $2 INTO v_$1 FROM $3')
    // String concatenation
    .replace(/\+\s*(?=[\w'"@])/g, ' || ')
    // String functions - Enhanced rules
    .replace(/\bCHARINDEX\s*\(\s*([^,]+),\s*([^)]+)\)/gi, 'INSTR($2, $1)')
    .replace(/\bLEN\s*\(\s*([^)]+)\s*\)/gi, 'LENGTH($1)')
    .replace(/\bLEFT\s*\(\s*([^,]+),\s*([^)]+)\s*\)/gi, 'SUBSTR($1, 1, $2)')
    .replace(/\bRIGHT\s*\(\s*([^,]+),\s*([^)]+)\s*\)/gi, 'SUBSTR($1, -$2)')
    .replace(/\bISNULL\s*\(\s*([^,]+),\s*([^)]+)\s*\)/gi, 'NVL($1, $2)')
    .replace(/\bCOALESCE\s*\(/gi, 'NVL(')
    .replace(/\bUPPER\s*\(/gi, 'UPPER(')
    .replace(/\bLOWER\s*\(/gi, 'LOWER(')
    .replace(/\bLTRIM\s*\(/gi, 'LTRIM(')
    .replace(/\bRTRIM\s*\(/gi, 'RTRIM(')
    .replace(/\bSUBSTRING\s*\(\s*([^,]+),\s*([^,]+),\s*([^)]+)\s*\)/gi, 'SUBSTR($1, $2, $3)')
    // Date/Time functions
    .replace(/\bDATEADD\s*\(\s*(\w+),\s*([^,]+),\s*([^)]+)\s*\)/gi, 'DATEADD_ORACLE($1, $2, $3)')
    .replace(/\bDATEDIFF\s*\(\s*(\w+),\s*([^,]+),\s*([^)]+)\s*\)/gi, 'DATEDIFF_ORACLE($1, $2, $3)')
    .replace(/\bDATEPART\s*\(\s*(\w+),\s*([^)]+)\s*\)/gi, 'EXTRACT($1 FROM $2)')
    .replace(/\bYEAR\s*\(\s*([^)]+)\s*\)/gi, 'EXTRACT(YEAR FROM $1)')
    .replace(/\bMONTH\s*\(\s*([^)]+)\s*\)/gi, 'EXTRACT(MONTH FROM $1)')
    .replace(/\bDAY\s*\(\s*([^)]+)\s*\)/gi, 'EXTRACT(DAY FROM $1)')
    // Control flow - Enhanced rules
    .replace(/IF\s+(.+?)\s+BEGIN/gi, 'IF $1 THEN')
    .replace(/ELSE\s+BEGIN/gi, 'ELSE')
    .replace(/END\s+IF/gi, 'END IF;')
    .replace(/WHILE\s+(.+?)\s+BEGIN/gi, 'WHILE $1 LOOP')
    .replace(/END\s+WHILE/gi, 'END LOOP;')
    .replace(/FOR\s+(.+?)\s+BEGIN/gi, 'FOR $1 LOOP')
    .replace(/END\s+FOR/gi, 'END LOOP;')
    // Exception handling
    .replace(/RAISERROR\s*\(\s*([^,]+),\s*([^,]+),\s*([^)]+)\s*\)/gi, 'RAISE_APPLICATION_ERROR(-20001, $1)')
    .replace(/TRY\s+BEGIN/gi, 'BEGIN')
    .replace(/END\s+TRY/gi, 'EXCEPTION WHEN OTHERS THEN')
    .replace(/CATCH\s+BEGIN/gi, 'BEGIN')
    .replace(/END\s+CATCH/gi, 'RAISE; END')
    // Print statements
    .replace(/PRINT\s+(.+)/gi, 'DBMS_OUTPUT.PUT_LINE($1)')
    // Data type conversions
    .replace(/\bINT\b/gi, 'NUMBER')
    .replace(/\bVARCHAR\s*\(\s*(\d+)\s*\)/gi, 'VARCHAR2($1)')
    .replace(/\bDECIMAL\s*\(\s*(\d+)\s*,\s*(\d+)\s*\)/gi, 'NUMBER($1,$2)')
    .replace(/\bFLOAT\b/gi, 'BINARY_FLOAT')
    .replace(/\bBIT\b/gi, 'NUMBER(1)')
    .replace(/\bgetdate\(\)/gi, 'SYSDATE')
    .replace(/\bGETDATE\(\)/gi, 'SYSDATE')
    // Conversion functions
    .replace(/\bCONVERT\s*\(\s*VARCHAR\s*\(\s*(\d+)\s*\),\s*([^)]+)\s*\)/gi, 'TO_CHAR($2)')
    .replace(/\bCONVERT\s*\(\s*INT,\s*([^)]+)\s*\)/gi, 'TO_NUMBER($1)')
    .replace(/\bCONVERT\s*\(\s*DATETIME,\s*([^)]+)\s*\)/gi, 'TO_DATE($1)')
    .replace(/\bCAST\s*\(\s*([^)]+)\s+AS\s+VARCHAR\s*\(\s*(\d+)\s*\)\s*\)/gi, 'TO_CHAR($1)')
    .replace(/\bCAST\s*\(\s*([^)]+)\s+AS\s+INT\s*\)/gi, 'TO_NUMBER($1)')
    // Transaction management
    .replace(/BEGIN\s+TRAN/gi, 'BEGIN')
    .replace(/COMMIT\s+TRAN/gi, 'COMMIT')
    .replace(/ROLLBACK\s+TRAN/gi, 'ROLLBACK')
    // Temporary tables
    .replace(/#(\w+)/g, 'TEMP_$1')
    // Remove square brackets
    .replace(/\[([^\]]+)\]/g, '$1')
    // Remove GO statements
    .replace(/\bGO\b/gi, '/');

  // Wrap in Oracle PL/SQL procedure
  return `
CREATE OR REPLACE PROCEDURE ${procName}
IS
BEGIN
${oracleCode}
EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
    ROLLBACK;
    RAISE;
END;
/`;
};

// Comprehensive trigger conversion
const simulateTriggerConversion = (sybaseCode: string): string => {
  const trigName = extractTriggerName(sybaseCode) || 'converted_trg';
  
  let oracleCode = sybaseCode
    // Remove CREATE TRIGGER header
    .replace(/CREATE\s+TRIGGER\s+\w+/gi, '')
    .replace(/ON\s+(\w+)\s+(FOR|AFTER)\s+(INSERT|UPDATE|DELETE)/gi, 'AFTER $3 ON $1')
    .replace(/INSTEAD\s+OF\s+(INSERT|UPDATE|DELETE)\s+ON\s+(\w+)/gi, 'INSTEAD OF $1 ON $2')
    // Special tables - Enhanced rules
    .replace(/\binserted\b/gi, ':NEW')
    .replace(/\bdeleted\b/gi, ':OLD')
    .replace(/SELECT\s+(.+)\s+FROM\s+inserted/gi, 'SELECT $1 FROM DUAL WHERE :NEW.$1 IS NOT NULL')
    .replace(/SELECT\s+(.+)\s+FROM\s+deleted/gi, 'SELECT $1 FROM DUAL WHERE :OLD.$1 IS NOT NULL')
    // Variable declarations
    .replace(/@(\w+)/g, 'v_$1')
    .replace(/DECLARE\s+@(\w+)\s+([^,;]+)/gi, 'v_$1 $2;')
    .replace(/SET\s+@(\w+)\s*=\s*/gi, 'v_$1 := ')
    // String concatenation
    .replace(/\+\s*(?=[\w'"@])/g, ' || ')
    // Functions
    .replace(/\bISNULL\s*\(\s*([^,]+),\s*([^)]+)\s*\)/gi, 'NVL($1, $2)')
    .replace(/\bgetdate\(\)/gi, 'SYSDATE')
    .replace(/\bGETDATE\(\)/gi, 'SYSDATE')
    .replace(/\bLEN\s*\(\s*([^)]+)\s*\)/gi, 'LENGTH($1)')
    // Data types
    .replace(/\bINT\b/gi, 'NUMBER')
    .replace(/\bVARCHAR\s*\(\s*(\d+)\s*\)/gi, 'VARCHAR2($1)')
    .replace(/\bDECIMAL\s*\(\s*(\d+)\s*,\s*(\d+)\s*\)/gi, 'NUMBER($1,$2)')
    .replace(/\bFLOAT\b/gi, 'BINARY_FLOAT')
    .replace(/\bBIT\b/gi, 'NUMBER(1)')
    // Exception handling
    .replace(/RAISERROR\s*\(\s*([^,]+),\s*([^,]+),\s*([^)]+)\s*\)/gi, 'RAISE_APPLICATION_ERROR(-20001, $1)')
    // Remove square brackets
    .replace(/\[([^\]]+)\]/g, '$1')
    .replace(/\bGO\b/gi, '/');

  return `
CREATE OR REPLACE TRIGGER ${trigName}
${oracleCode}
EXCEPTION
  WHEN OTHERS THEN
    RAISE_APPLICATION_ERROR(-20001, 'Trigger error: ' || SQLERRM);
END;
/`;
};

// Generic conversion for other file types with comprehensive rules
const simulateGenericConversion = (sybaseCode: string): string => {
  return sybaseCode
    // Basic data type conversions
    .replace(/\bINT\b/gi, 'NUMBER')
    .replace(/\bBIGINT\b/gi, 'NUMBER(19)')
    .replace(/\bSMALLINT\b/gi, 'NUMBER(5)')
    .replace(/\bTINYINT\b/gi, 'NUMBER(3)')
    .replace(/\bFLOAT\b/gi, 'BINARY_FLOAT')
    .replace(/\bREAL\b/gi, 'BINARY_FLOAT')
    .replace(/\bDECIMAL\s*\(\s*(\d+)\s*,\s*(\d+)\s*\)/gi, 'NUMBER($1,$2)')
    .replace(/\bVARCHAR\s*\(\s*(\d+)\s*\)/gi, 'VARCHAR2($1)')
    .replace(/\bCHAR\s*\(\s*(\d+)\s*\)/gi, 'CHAR($1)')
    .replace(/\bDATETIME\b/gi, 'DATE')
    .replace(/\bBIT\b/gi, 'NUMBER(1)')
    .replace(/\bTEXT\b/gi, 'CLOB')
    .replace(/\bIMAGE\b/gi, 'BLOB')
    // Functions
    .replace(/\bgetdate\(\)/gi, 'SYSDATE')
    .replace(/\bGETDATE\(\)/gi, 'SYSDATE')
    .replace(/\bISNULL\s*\(\s*([^,]+),\s*([^)]+)\s*\)/gi, 'NVL($1, $2)')
    .replace(/\bLEN\s*\(\s*([^)]+)\s*\)/gi, 'LENGTH($1)')
    .replace(/\bCHARINDEX\s*\(\s*([^,]+),\s*([^)]+)\)/gi, 'INSTR($2, $1)')
    .replace(/\bLEFT\s*\(\s*([^,]+),\s*([^)]+)\s*\)/gi, 'SUBSTR($1, 1, $2)')
    .replace(/\bRIGHT\s*\(\s*([^,]+),\s*([^)]+)\s*\)/gi, 'SUBSTR($1, -$2)')
    .replace(/\bSUBSTRING\s*\(\s*([^,]+),\s*([^,]+),\s*([^)]+)\s*\)/gi, 'SUBSTR($1, $2, $3)')
    // String concatenation
    .replace(/\+\s*(?=[\w'"@])/g, ' || ')
    // Conversion functions
    .replace(/\bCONVERT\s*\(\s*VARCHAR\s*\(\s*(\d+)\s*\),\s*([^)]+)\s*\)/gi, 'TO_CHAR($2)')
    .replace(/\bCONVERT\s*\(\s*INT,\s*([^)]+)\s*\)/gi, 'TO_NUMBER($1)')
    .replace(/\bCONVERT\s*\(\s*DATETIME,\s*([^)]+)\s*\)/gi, 'TO_DATE($1)')
    // Remove square brackets and GO statements
    .replace(/\[([^\]]+)\]/g, '$1')
    .replace(/\bGO\b/gi, '/');
};

// Helper functions for extracting names
const extractProcedureName = (code: string): string | null => {
  const match = code.match(/CREATE\s+(?:OR\s+REPLACE\s+)?PROCEDURE\s+(\w+)/i);
  return match ? match[1] : null;
};

const extractTriggerName = (code: string): string | null => {
  const match = code.match(/CREATE\s+(?:OR\s+REPLACE\s+)?TRIGGER\s+(\w+)/i);
  return match ? match[1] : null;
};

// Comprehensive validation with all Oracle rules
export const validateOracleCode = (code: string): ConversionIssue[] => {
  const issues: ConversionIssue[] = [];
  const lines = code.split('\n');
  
  lines.forEach((line, index) => {
    const lineNumber = index + 1;
    
    // Check for Sybase-specific data types
    if (line.match(/\bINT\b/i) && !line.includes('-- Converted Oracle code')) {
      issues.push({
        id: crypto.randomUUID(),
        lineNumber,
        description: 'INT is not an Oracle data type, use NUMBER instead',
        severity: 'error',
        originalCode: 'INT',
        suggestedFix: 'NUMBER'
      });
    }
    
    if (line.match(/\bVARCHAR\s*\(/i) && !line.match(/\bVARCHAR2\s*\(/i)) {
      issues.push({
        id: crypto.randomUUID(),
        lineNumber,
        description: 'VARCHAR should be VARCHAR2 in Oracle',
        severity: 'error',
        originalCode: 'VARCHAR',
        suggestedFix: 'VARCHAR2'
      });
    }
    
    // Check for string concatenation
    if (line.match(/\+\s*(?=[\w'"])/)) {
      issues.push({
        id: crypto.randomUUID(),
        lineNumber,
        description: 'Use || for string concatenation in Oracle',
        severity: 'error',
        originalCode: 'string1 + string2',
        suggestedFix: 'string1 || string2'
      });
    }
    
    // Check for Sybase functions
    if (line.match(/\bgetdate\(\)/i)) {
      issues.push({
        id: crypto.randomUUID(),
        lineNumber,
        description: 'Use SYSDATE instead of GETDATE() in Oracle',
        severity: 'error',
        originalCode: 'GETDATE()',
        suggestedFix: 'SYSDATE'
      });
    }
    
    if (line.match(/\bISNULL\s*\(/i)) {
      issues.push({
        id: crypto.randomUUID(),
        lineNumber,
        description: 'Use NVL instead of ISNULL in Oracle',
        severity: 'error',
        originalCode: 'ISNULL(a, b)',
        suggestedFix: 'NVL(a, b)'
      });
    }
    
    // Check for square brackets
    if (line.match(/\[[^\]]+\]/)) {
      issues.push({
        id: crypto.randomUUID(),
        lineNumber,
        description: 'Remove square brackets around identifiers in Oracle',
        severity: 'error',
        originalCode: '[identifier]',
        suggestedFix: 'identifier'
      });
    }
    
    // Check for LEN function
    if (line.match(/\bLEN\s*\(/i)) {
      issues.push({
        id: crypto.randomUUID(),
        lineNumber,
        description: 'Use LENGTH instead of LEN in Oracle',
        severity: 'error',
        originalCode: 'LEN(x)',
        suggestedFix: 'LENGTH(x)'
      });
    }
    
    // Check for CHARINDEX function
    if (line.match(/\bCHARINDEX\s*\(/i)) {
      issues.push({
        id: crypto.randomUUID(),
        lineNumber,
        description: 'Use INSTR instead of CHARINDEX in Oracle',
        severity: 'error',
        originalCode: 'CHARINDEX(x, y)',
        suggestedFix: 'INSTR(y, x)'
      });
    }
  });
  
  return issues;
};

export const generateConversionReport = (results: ConversionResult[]): string => {
  const successCount = results.filter(r => r.status === 'success').length;
  const warningCount = results.filter(r => r.status === 'warning').length;
  const errorCount = results.filter(r => r.status === 'error').length;
  
  return `
# Code Conversion Report

## Summary
- **Files Processed**: ${results.length}
- **Successfully Converted**: ${successCount}
- **Converted with Warnings**: ${warningCount}
- **Failed Conversions**: ${errorCount}
- **Overall Success Rate**: ${Math.round((successCount + warningCount) / results.length * 100)}%

## Detailed Findings

${results.map(result => `
### ${result.originalFile.name} (${result.originalFile.type})
- **Status**: ${result.status.toUpperCase()}
- **Issues Found**: ${result.issues.length}
${result.issues.map(issue => `- ${issue.severity.toUpperCase()}: ${issue.description}`).join('\n')}
- **Performance Improvement**: ${result.performance?.improvementPercentage}%
`).join('\n')}

## Recommendations

- Review all warnings and errors manually
- Test the converted code thoroughly
- Consider performance testing for critical procedures
`;
};
